import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
from typing import List, Tuple, Dict
import re
import math
import json
# ==========================================
# 1. Configuration Class (설정 관리)
# ==========================================
class WaveformConfig:
    """애플리케이션의 모든 상수와 설정을 관리하는 클래스"""
    def __init__(self):
        self.num_cycles = 64      # 기본 사이클 수
        self.num_waves = 4        # 기본 파형 개수
        self.cell_width = 20      # 한 클럭의 픽셀 너비
        self.row_height = 50      # 파형 한 줄의 높이
        
        # UI Colors & Layout
        self.high_y_offset = 10
        self.low_y_offset = 40
        self.grid_color = "#e0e0e0"
        self.wave_color = "#000000"
        self.sidebar_width = 340  # 컨트롤 패널 너비

    @property
    def total_width(self):
        return self.num_cycles * self.cell_width

    @property
    def total_height(self):
        return self.num_waves * self.row_height

# ==========================================
# 2. Logic Class: Verilog-A Generator
# ==========================================
class VerilogAGenerator:
    """
    GUI와 독립적으로 Verilog-A 코드를 생성하는 로직 클래스.
    ★ Drift 해결: $abstime 계산 방식을 버리고, @timer 이벤트 기반으로 값을 직접 할당.
    """
    
    @staticmethod
    def sanitize_name(name: str, default: str = "wave") -> str:
        s = name.strip()
        s = re.sub(r"[^A-Za-z0-9_]", "_", s)
        if not s: s = default
        if s[0].isdigit(): s = f"w_{s}"
        return s

    @staticmethod
    def generate(waveforms: List[List[int]], 
                 names: List[str], 
                 modes: List[str], 
                 params: Dict) -> str:
        
        tck_str = params.get('tck_str', '10n')
        tr_str = params.get('tr_str', '10p')
        tf_str = params.get('tf_str', '10p')
        vhigh = params['vhigh']
        vlow = params['vlow']
        
        sanitized_names = [VerilogAGenerator.sanitize_name(n, f"sig_{i}") for i, n in enumerate(names)]
        
        # 주기적 신호가 있는지 확인하고, 있다면 GUI 길이를 가져옴
        has_periodic = any(m == "반복" for m in modes)
        gui_len = len(waveforms[0]) if waveforms else 0
        
        lines = [
            '// Auto-generated by Python Waveform Editor (Event-Driven Version)',
            '`include "discipline.h"',
            '`include "constants.h"',
            '',
            f'module pwl_waves({", ".join(sanitized_names)});',
            f'    output {", ".join(sanitized_names)};',
            f'    electrical {", ".join(sanitized_names)};',
            '',
            '    // User Parameters',
            f'    parameter real tck = {tck_str};  // Clock Period (1 Cycle)',
            f'    parameter real tr  = {tr_str};   // Rising Time',
            f'    parameter real tf  = {tf_str};   // Falling Time',
            f'    parameter real vlow = {vlow};',
            f'    parameter real vhigh = {vhigh};',
            ''
            '    // Repetition Parameters (auto-generated for periodic signals)',
        ]

        # 주기적 신호가 있을 경우, 단일 period_factor 파라미터를 추가
        if has_periodic and gui_len > 0:
            period_factor_value = gui_len * 0.5
            lines.append(f"    parameter real period_factor = {period_factor_value:.12g}; // Period factor for all periodic signals")
            lines.append('') # 가독성을 위한 공백

        real_vars = set()
        initial_block = []
        analog_body = []
        transitions = []

        for idx, wf in enumerate(waveforms):
            name = sanitized_names[idx]
            mode = modes[idx]
            vsel = f"vsel_{idx}"
            real_vars.add(vsel)
            
            # 1. 초기 상태 설정 (@initial_step)
            # 파형의 0번째 값을 초기값으로 설정
            init_val = vhigh if wf and wf[0] else vlow
            initial_block.append(f"        {vsel} = {init_val:.12g};")

            analog_body.append(f"    // Logic for {name} ({mode}) - Event Driven")
            
            is_periodic = (mode == "반복")
            
            # 2. 변경 포인트 감지 및 @timer 코드 생성
            
            if is_periodic:
                period_expr = "(period_factor * tck)"
                
                # (1) Wrap-around 처리 (마지막 값 -> 첫 값 변경 시 0초에 이벤트 필요)
                # 주기적 신호는 wf[-1]에서 wf[0]으로 넘어갈 때 값이 다르면 0초 타이머가 필요함
                prev_val = wf[-1] 
                
                # 0부터 끝까지 순회
                for i in range(len(wf)):
                    curr_val = wf[i]
                    if curr_val != prev_val:
                        # 값이 변하는 순간!
                        time_offset = i * 0.5
                        target_volt = vhigh if curr_val else vlow
                        
                        # @timer(시작시간, 주기)
                        if time_offset == 0:
                            # 0초(주기 시작점) 타이머
                            analog_body.append(f"    @(timer(0, {period_expr})) {vsel} = {target_volt:.12g};")
                        else:
                            # 중간 타이머
                            analog_body.append(f"    @(timer({time_offset:.12g} * tck, {period_expr})) {vsel} = {target_volt:.12g};")
                    
                    prev_val = curr_val
                    
            else:
                # One-shot 모드
                prev_val = wf[0]
                # 0번째 인덱스는 초기값으로 설정되므로, 1번째부터 변화 감지
                for i in range(1, len(wf)):
                    curr_val = wf[i]
                    if curr_val != prev_val:
                        time_offset = i * 0.5
                        target_volt = vhigh if curr_val else vlow
                        # 반복 없는 단발성 타이머
                        analog_body.append(f"    @(timer({time_offset:.12g} * tck)) {vsel} = {target_volt:.12g};")
                        prev_val = curr_val
                
                # GUI 윈도우가 끝난 후 0(Low)으로 떨어지도록 설정 (옵션)
                end_time_expr = f"({gui_len * 0.5:.12g} * tck)"
                if prev_val != 0: # 마지막이 High 상태로 끝났다면
                     analog_body.append(f"    @(timer({end_time_expr})) {vsel} = {vlow:.12g};")

            analog_body.append("")
            transitions.append(f"    V({name}) <+ transition({vsel}, 0, tr, tf);")

        if real_vars: lines.append(f"    real {', '.join(sorted(list(real_vars)))};")
        
        # 정수는 더 이상 필요 없음 (n_0, n_1 등 삭제)
            
        lines.append("\n    analog begin")
        
        # 초기화 블록
        if initial_block:
            lines.append("        @(initial_step) begin")
            lines.extend(initial_block)
            lines.append("        end\n")
            
        lines.extend(analog_body)
        lines.extend(transitions)
        lines.append("    end")
        lines.append("endmodule")
        return "\n".join(lines)

class Signal:
    """하나의 파형에 대한 모든 데이터를 캡슐화하는 클래스"""
    def __init__(self, name: str, mode: str, waveform: List[int]):
        self.name = tk.StringVar(value=name)
        self.mode = tk.StringVar(value=mode)
        self.waveform = waveform

    def get_data_dict(self) -> Dict:
        """저장/내보내기를 위한 순수 데이터 딕셔너리 반환"""
        return {
            "name": self.name.get(),
            "mode": self.mode.get(),
            "waveform": list(self.waveform) # 참조가 아닌 리스트 복사본을 반환
        }

class WaveformModel:
    """애플리케이션의 데이터 모델과 비즈니스 로직을 관리"""
    def __init__(self, num_cycles: int, num_waves: int):
        self.num_cycles = num_cycles
        self.signals: List[Signal] = []
        self.clipboard: Dict = None
        self.active_wave_idx = 0

        # Undo/Redo 스택
        self.undo_stack: List[Dict] = []
        self.redo_stack: List[Dict] = []
        self.history_limit = 50 # 최대 저장 기록 수
        
        for i in range(num_waves):
            self.add_signal(f"Signal_{i+1}")

    @property
    def num_waves(self) -> int:
        return len(self.signals)

    def add_signal(self, name: str, mode: str = "one-shot", waveform: List[int] = None):
        if waveform is None:
            waveform = [0] * self.num_cycles
        self.signals.append(Signal(name, mode, waveform))

    def _get_state(self) -> Dict:
        """현재 모델의 상태를 딕셔너리로 반환 (깊은 복사)"""
        return {
            "num_cycles": self.num_cycles,
            "signals": [s.get_data_dict() for s in self.signals]
        }

    def _set_state(self, state: Dict):
        """주어진 상태로 모델을 복원"""
        self.num_cycles = state["num_cycles"]
        self.signals = [
            Signal(s['name'], s['mode'], s['waveform']) for s in state['signals']
        ]
        # 활성화 인덱스가 범위를 벗어나지 않도록 조정
        if self.active_wave_idx >= self.num_waves:
            self.active_wave_idx = self.num_waves - 1

    def save_state_for_undo(self):
        """현재 상태를 Undo 스택에 저장합니다."""
        self.undo_stack.append(self._get_state())
        if len(self.undo_stack) > self.history_limit:
            self.undo_stack.pop(0) # 가장 오래된 기록 삭제
        self.redo_stack.clear() # 새로운 변경이 생겼으므로 Redo 스택은 비움

    def undo(self) -> bool:
        if not self.undo_stack: return False
        current_state = self._get_state()
        self.redo_stack.append(current_state)
        self._set_state(self.undo_stack.pop())
        return True

    def redo(self) -> bool:
        if not self.redo_stack: return False
        current_state = self._get_state()
        self.undo_stack.append(current_state)
        self._set_state(self.redo_stack.pop())
        return True

    def move_wave(self, idx: int, direction: str):
        target_idx = -1
        if direction == 'up' and idx > 0:
            target_idx = idx - 1
        elif direction == 'down' and idx < self.num_waves - 1:
            target_idx = idx + 1
        
        if target_idx != -1:
            self.signals[idx], self.signals[target_idx] = self.signals[target_idx], self.signals[idx]
            # 활성화 인덱스도 함께 조정
            if self.active_wave_idx == idx:
                self.active_wave_idx = target_idx
            elif self.active_wave_idx == target_idx:
                self.active_wave_idx = idx

    def copy_active_wave(self):
        if 0 <= self.active_wave_idx < self.num_waves:
            self.clipboard = self.signals[self.active_wave_idx].get_data_dict()

    def paste_to_active_wave(self) -> bool:
        if not self.clipboard: return False
        active_sig = self.signals[self.active_wave_idx]
        active_sig.name.set(self.clipboard["name"])
        active_sig.mode.set(self.clipboard["mode"])
        copied_wave = self.clipboard["waveform"]
        pasted_wave = (copied_wave + [0] * self.num_cycles)[:self.num_cycles]
        active_sig.waveform = pasted_wave
        return True

# ==========================================
# 3. Main GUI Class
# ==========================================
class WaveformEditor:
    def __init__(self, master: tk.Tk):
        self.master = master
        self.cfg = WaveformConfig()
        # Model 인스턴스 생성
        self.model = WaveformModel(self.cfg.num_cycles, self.cfg.num_waves)

        self.master.title(f"Waveform Editor - {self.cfg.num_cycles} Cycles")
        
        # UI 상태 변수
        self.cursor_index = 0
        self.pulse_len_buf = ""

        # 모델의 active_wave_idx를 직접 사용하거나, getter/setter를 만들 수 있습니다.
        # self.active_wave_idx = self.model.active_wave_idx 
        # 여기서는 self.model.active_wave_idx를 직접 참조하는 것으로 가정합니다.
        
        # UI Setup
        self._setup_menu()
        self._setup_layout()
        
        # 초기 파형 변수 생성
        for i in range(self.cfg.num_waves):
            self.model.signals[i].name.trace_add("write", lambda *_, i=i: self._check_clk_name(i))
            
        self._rebuild_control_panel()
        self._bind_events()
        self._redraw_all()
        
        self.status_var.set("Ready. 'CLK'를 이름에 입력하면 자동 클럭이 생성됩니다.")
    
    def _setup_menu(self):
        # ... (변경 없음)
        pass

    def _setup_layout(self):
        menubar = tk.Menu(self.master)
        self.master.config(menu=menubar)

        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="파일 (File)", menu=file_menu)
        file_menu.add_command(label="파형 저장 (Save Waveform)...", command=self._save_waveform)
        file_menu.add_command(label="파형 불러오기 (Load Waveform)...", command=self._load_waveform)
        file_menu.add_separator()
        file_menu.add_command(label="종료 (Exit)", command=self.master.quit)

        edit_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="편집 (Edit)", menu=edit_menu)
        edit_menu.add_command(label="실행 취소 (Undo)", accelerator="Ctrl+Z", command=self._undo)
        edit_menu.add_command(label="다시 실행 (Redo)", accelerator="Ctrl+Y", command=self._redo)

        settings_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="설정 (Settings)", menu=settings_menu)
        settings_menu.add_command(label="그리드 크기 변경 (Grid Size)...", command=self._open_grid_settings)
        self.main_pane = ttk.PanedWindow(self.master, orient=tk.HORIZONTAL)
        self.main_pane.pack(fill=tk.BOTH, expand=True)
        
        # Left Sidebar
        self.sidebar = ttk.Frame(self.main_pane, width=200)
        self.main_pane.add(self.sidebar, weight=0)
        
        info_frame = ttk.LabelFrame(self.sidebar, text="Info", padding=5)
        info_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.text_info = tk.Text(info_frame, width=25, height=10, state="disabled", font=("Consolas", 9))
        self.text_info.pack(fill=tk.BOTH, expand=True)
        
        btn_frame = ttk.Frame(self.sidebar, padding=5)
        btn_frame.pack(fill=tk.X, side=tk.BOTTOM)
        ttk.Button(btn_frame, text="Clear Wave", command=self._clear_current_wave).pack(fill=tk.X, pady=2)
        ttk.Button(btn_frame, text="Export Verilog-A", command=self._export_verilog_a).pack(fill=tk.X, pady=2)

        # Work Area
        self.work_area = ttk.Frame(self.main_pane)
        self.main_pane.add(self.work_area, weight=1)
        
        self.h_scroll = ttk.Scrollbar(self.work_area, orient="horizontal")
        self.h_scroll.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.wave_container = ttk.Frame(self.work_area)
        self.wave_container.pack(fill=tk.BOTH, expand=True)
        
        self.controls_frame = ttk.Frame(self.wave_container, width=self.cfg.sidebar_width)
        self.controls_frame.pack(side=tk.LEFT, fill=tk.Y)
        self.controls_frame.pack_propagate(False)
        
        self.canvas = tk.Canvas(self.wave_container, bg="white", highlightthickness=0)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.canvas.configure(xscrollcommand=self.h_scroll.set)
        self.h_scroll.configure(command=self.canvas.xview)
        
        self.status_var = tk.StringVar()
        self.statusbar = ttk.Label(self.master, textvariable=self.status_var, relief=tk.SUNKEN, anchor="w")
        self.statusbar.pack(side=tk.BOTTOM, fill=tk.X)

    def _rebuild_control_panel(self):
        for widget in self.controls_frame.winfo_children():
            widget.destroy()
            
        for i, sig in enumerate(self.model.signals):
            row_f = ttk.Frame(self.controls_frame, height=self.cfg.row_height, style="Controls.TFrame")
            row_f.pack(fill=tk.X, pady=0)
            row_f.pack_propagate(False)
            
            # 파형 이동 버튼
            move_btn_frame = ttk.Frame(row_f, style="Controls.TFrame")
            move_btn_frame.pack(side=tk.LEFT, padx=(2,0), fill=tk.Y)
            
            up_btn = ttk.Button(move_btn_frame, text="▲", width=2, command=lambda i=i: self._move_wave(i, 'up'))
            up_btn.pack(side=tk.TOP, expand=True, fill=tk.BOTH, pady=(1,0))
            if i == 0:
                up_btn.config(state="disabled")

            down_btn = ttk.Button(move_btn_frame, text="▼", width=2, command=lambda i=i: self._move_wave(i, 'down'))
            down_btn.pack(side=tk.BOTTOM, expand=True, fill=tk.BOTH, pady=(0,1))
            if i == self.model.num_waves - 1:
                down_btn.config(state="disabled")

            # 나머지 컨트롤
            controls_inner_frame = ttk.Frame(row_f, style="Controls.TFrame")
            controls_inner_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, pady=10)
            
            ttk.Label(controls_inner_frame, text=f"W{i+1}", width=4, anchor="center").pack(side=tk.LEFT, padx=2)
            entry = ttk.Entry(controls_inner_frame, textvariable=sig.name, width=10, justify="center")
            entry.pack(side=tk.LEFT, padx=2)
            
            combo = ttk.Combobox(controls_inner_frame, textvariable=sig.mode, values=["one-shot", "반복"], width=8, state="readonly")
            combo.pack(side=tk.LEFT, padx=2)

    def _check_clk_name(self, idx):
        if idx >= self.model.num_waves: return
        
        name = self.model.signals[idx].name.get().lower().strip()
        if name == "clk":
            self.model.signals[idx].waveform = [i % 2 for i in range(self.cfg.num_cycles)]
            self.model.signals[idx].mode.set("반복")
            self._redraw_all()
            self.status_var.set(f"Wave {idx+1}: Auto-generated CLK pattern.")

    def _open_grid_settings(self):
        top = tk.Toplevel(self.master)
        top.title("Grid Settings")
        top.geometry("300x160")
        top.transient(self.master)
        top.grab_set()

        ttk.Label(top, text="Cycles (Length):").place(x=30, y=30)
        entry_cycles = ttk.Entry(top, width=10)
        entry_cycles.place(x=150, y=30)
        entry_cycles.insert(0, str(self.cfg.num_cycles))

        ttk.Label(top, text="Waves (Count):").place(x=30, y=70)
        entry_waves = ttk.Entry(top, width=10)
        entry_waves.place(x=150, y=70)
        entry_waves.insert(0, str(self.cfg.num_waves))

        def on_confirm():
            try:
                nc = int(entry_cycles.get())
                nw = int(entry_waves.get())
                if nc < 1 or nw < 1: raise ValueError
                self._reconfigure_grid(nc, nw)
                top.destroy()
            except ValueError:
                messagebox.showerror("Error", "Please enter positive integers.")

        ttk.Button(top, text="Apply", command=on_confirm).place(x=100, y=110)
        top.bind("<Return>", lambda e: on_confirm())

    def _reconfigure_grid(self, new_cycles: int, new_waves: int):
        self.model.save_state_for_undo()
        old_cycles = self.cfg.num_cycles
        old_waves = self.cfg.num_waves

        self.cfg.num_cycles = new_cycles
        self.cfg.num_waves = new_waves # cfg도 업데이트하지만, model의 길이가 기준이 됨

        # 모델에게 그리드 재설정을 위임 (이 로직은 WaveformModel로 이동)
        # self.model.reconfigure(new_cycles, new_waves)

        if new_waves > old_waves:
            for i in range(old_waves, new_waves):
                self.model.add_signal(f"Signal_{i+1}", waveform=[0] * old_cycles)
                self.model.signals[i].name.trace_add("write", lambda *_, i=i: self._check_clk_name(i))
        elif new_waves < old_waves:
            self.model.signals = self.model.signals[:new_waves]

        for sig in self.model.signals:
            curr = len(sig.waveform)
            if new_cycles > curr:
                sig.waveform.extend([0] * (new_cycles - curr))
            elif new_cycles < curr:
                sig.waveform = sig.waveform[:new_cycles]
        self.model.num_cycles = new_cycles

        self._rebuild_control_panel()
        self.master.title(f"Waveform Editor - {self.cfg.num_cycles} Cycles")
        self.model.active_wave_idx = 0
        self.cursor_index = 0
        self._redraw_all()
        self.status_var.set(f"Resized: {new_waves} Waves x {new_cycles} Cycles")

    def _bind_events(self):
        self.canvas.bind("<Button-1>", lambda e: self._handle_click(e, 1)) 
        self.canvas.bind("<B1-Motion>", lambda e: self._handle_drag(e, 1))
        self.canvas.bind("<Button-3>", lambda e: self._handle_click(e, 0))
        self.canvas.bind("<B3-Motion>", lambda e: self._handle_drag(e, 0))
        
        self.master.bind("<Key>", self._on_key_press)
        self.master.bind("<Return>", lambda e: self._apply_buffered_length(1))
        self.master.bind("<Shift-Return>", lambda e: self._apply_buffered_length(0))
        
        # 복사/붙여넣기 단축키
        self.master.bind("<Control-c>", self._copy_wave)
        self.master.bind("<Control-v>", self._paste_wave)
        
        # Undo/Redo 단축키
        self.master.bind("<Control-z>", self._undo)
        self.master.bind("<Control-y>", self._redo)

    def _redraw_all(self):
        self.canvas.delete("all")
        total_w = self.cfg.total_width
        total_h = self.cfg.total_height
        
        self.canvas.configure(scrollregion=(0, 0, total_w + 50, total_h))
        
        for i in range(self.cfg.num_waves):
            y_base = i * self.cfg.row_height
            self.canvas.create_line(0, y_base, total_w, y_base, fill=self.cfg.grid_color)
            if i == self.model.active_wave_idx:
                self.canvas.create_rectangle(0, y_base, total_w, y_base + self.cfg.row_height, 
                                             fill="#f0f8ff", outline="", tags="bg")

        for c in range(self.cfg.num_cycles + 1):
            x = c * self.cfg.cell_width
            self.canvas.create_line(x, 0, x, total_h, fill=self.cfg.grid_color, dash=(2, 4))
            if c % 4 == 0:
                self.canvas.create_text(x + 2, total_h - 10, text=str(c), anchor="sw", fill="gray", font=("", 8))

        for i in range(self.cfg.num_waves):
            self._draw_single_wave(i)

    def _draw_single_wave(self, idx):
        wf = self.model.signals[idx].waveform
        y_base = idx * self.cfg.row_height
        high_y = y_base + self.cfg.high_y_offset
        low_y = y_base + self.cfg.low_y_offset
        
        points = []
        cur_x = 0
        cur_y = high_y if wf[0] else low_y
        points.append(cur_x); points.append(cur_y)
        
        for c in range(1, len(wf)):
            x = c * self.cfg.cell_width
            prev = wf[c-1]
            curr = wf[c]
            target_y = high_y if curr else low_y
            if prev != curr:
                points.append(x); points.append(cur_y)
                points.append(x); points.append(target_y)
                cur_y = target_y
        points.append(len(wf) * self.cfg.cell_width)
        points.append(cur_y)
        
        color = "blue" if idx == self.model.active_wave_idx else self.cfg.wave_color
        width = 3 if idx == self.model.active_wave_idx else 2
        self.canvas.create_line(points, fill=color, width=width, tags=f"wave_{idx}")

    def _get_target_from_event(self, event) -> Tuple[int, int]:
        """
        이벤트 좌표로부터 파형 인덱스와 사이클 인덱스를 계산합니다.
        클릭 위치가 유효한 파형 영역(high/low offset 사이)이 아니면 (None, None)을 반환합니다.
        """
        cx = self.canvas.canvasx(event.x)
        cy = self.canvas.canvasy(event.y)

        # 전체 파형 영역을 벗어나는 클릭인지 먼저 확인
        if not (0 <= cy < self.cfg.total_height):
            return None, None

        # Y 좌표가 파형의 유효 높이 범위 내에 있는지 확인
        y_in_row = cy % self.cfg.row_height
        if not (self.cfg.high_y_offset <= y_in_row <= self.cfg.low_y_offset):
            return None, None

        w_idx = int(cy // self.cfg.row_height)
        c_idx = int(cx // self.cfg.cell_width)

        w_idx = max(0, min(w_idx, self.cfg.num_waves - 1))
        c_idx = max(0, min(c_idx, self.cfg.num_cycles - 1))
        return w_idx, c_idx

    def _handle_click(self, event, val):
        w_idx, c_idx = self._get_target_from_event(event)
        if w_idx is None:  # 유효하지 않은 클릭 위치
            return

        self.model.save_state_for_undo()
        self.master.focus_set()
        self.model.active_wave_idx = w_idx
        self.cursor_index = c_idx
        self.pulse_len_buf = ""
        self.model.signals[w_idx].waveform[c_idx] = val
        self._update_ui_after_change()

    def _handle_drag(self, event, val):
        w_idx, c_idx = self._get_target_from_event(event)
        if w_idx is None: # 유효하지 않은 드래그 위치
            return

        # TODO: 드래그 시작 시 한 번만 상태를 저장하도록 개선할 수 있음
        if w_idx != self.model.active_wave_idx:
            self.model.active_wave_idx = w_idx
        self.model.signals[w_idx].waveform[c_idx] = val
        self.cursor_index = c_idx
        self._update_ui_after_change()

    def _move_wave(self, idx: int, direction: str):
        """지정된 파형을 위 또는 아래로 한 칸 이동시킵니다."""
        self.model.save_state_for_undo()
        self.model.move_wave(idx, direction)
        self._rebuild_control_panel()
        self._redraw_all()

    def _copy_wave(self, event=None):
        """활성화된 파형을 클립보드에 복사합니다 (Ctrl+C)."""
        if isinstance(self.master.focus_get(), ttk.Entry):
            return # 텍스트 입력 중에는 동작 안 함
        
        self.model.copy_active_wave()
        self.status_var.set(f"Wave {self.model.active_wave_idx + 1} '{self.model.clipboard['name']}' copied.")

    def _paste_wave(self, event=None):
        """클립보드의 파형을 활성화된 위치에 붙여넣습니다 (Ctrl+V)."""
        if isinstance(self.master.focus_get(), ttk.Entry):
            return # 텍스트 입력 중에는 동작 안 함
        
        self.model.save_state_for_undo()
        if self.model.paste_to_active_wave():
            self._update_ui_after_change()
            self.status_var.set(f"Pasted to Wave {self.model.active_wave_idx + 1}.")
        else:
            self.status_var.set("Clipboard is empty.")

    def _undo(self, event=None):
        if self.model.undo():
            self._full_ui_update_after_state_change()
            self.status_var.set("Undo successful.")
        else:
            self.status_var.set("Nothing to undo.")

    def _redo(self, event=None):
        if self.model.redo():
            self._full_ui_update_after_state_change()
            self.status_var.set("Redo successful.")
        else:
            self.status_var.set("Nothing to redo.")

    def _update_ui_after_change(self):
        self._redraw_all()
        self._update_info_panel()
        active_idx = self.model.active_wave_idx
        val = self.model.signals[active_idx].waveform[self.cursor_index]
        val_str = "HIGH" if val else "LOW"
        self.status_var.set(f"Wave {active_idx+1} @ {self.cursor_index}: Set {val_str}")

    def _full_ui_update_after_state_change(self):
        """Undo/Redo 같이 모델 전체가 바뀔 때 UI를 완전히 새로고침합니다."""
        # 모델의 변경사항을 Config에도 반영
        self.cfg.num_cycles = self.model.num_cycles
        self.cfg.num_waves = self.model.num_waves
        # 컨트롤 패널과 캔버스 모두 새로 그림
        self._rebuild_control_panel()
        self._redraw_all()
        self._update_info_panel()

    def _on_key_press(self, event):
        if isinstance(self.master.focus_get(), ttk.Entry): return
        if event.char.isdigit():
            self.pulse_len_buf += event.char
            self.status_var.set(f"Input Length: {self.pulse_len_buf} (Press Enter to Apply High)")

    def _apply_buffered_length(self, val):
        if not self.pulse_len_buf: return
        try:
            self.model.save_state_for_undo()
            length = int(self.pulse_len_buf)
            start = self.cursor_index
            end = min(self.cfg.num_cycles, start + length)
            active_wave = self.model.signals[self.model.active_wave_idx].waveform
            for i in range(start, end):
                active_wave[i] = val
            self._update_ui_after_change()
            self.pulse_len_buf = ""
        except ValueError: pass

    def _update_info_panel(self):
        self.text_info.configure(state="normal")
        self.text_info.delete("1.0", tk.END)
        wf = self.model.signals[self.model.active_wave_idx].waveform
        pulses = []
        in_pulse = False
        start = 0
        for i, v in enumerate(wf):
            if v == 1 and not in_pulse:
                in_pulse = True; start = i
            elif v == 0 and in_pulse:
                in_pulse = False; pulses.append((start, i - start))
        if in_pulse: pulses.append((start, len(wf) - start))
        
        self.text_info.insert(tk.END, f"[Signal {self.model.active_wave_idx+1}]\nTotal: {len(wf)}\nPulses: {len(pulses)}\n\n")
        for i, (s, w) in enumerate(pulses):
            self.text_info.insert(tk.END, f"#{i+1}: Start={s}, W={w}\n")
        self.text_info.configure(state="disabled")

    def _clear_current_wave(self):
        self.model.save_state_for_undo()
        active_wave = self.model.signals[self.model.active_wave_idx].waveform
        for i in range(len(active_wave)):
            active_wave[i] = 0
        self._update_ui_after_change()

    def _save_waveform(self):
        # 저장/불러오기는 Undo/Redo 기록에 포함하지 않음
        """현재 파형 상태를 JSON 파일로 저장합니다."""
        path = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("Waveform JSON", "*.json"), ("All Files", "*.*")]
        )
        if not path:
            return

        data_to_save = {
            "config": {
                "num_cycles": self.cfg.num_cycles,
                "num_waves": self.cfg.num_waves,
            },
            "signals": [s.get_data_dict() for s in self.model.signals]
        }

        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump(data_to_save, f, indent=2)
            self.status_var.set(f"Waveform saved to {path}")
            messagebox.showinfo("Success", f"Waveform saved successfully!")
        except Exception as e:
            messagebox.showerror("Save Error", f"Failed to save file:\n{e}")

    def _load_waveform(self):
        """JSON 파일에서 파형 상태를 불러옵니다."""
        path = filedialog.askopenfilename(
            filetypes=[("Waveform JSON", "*.json"), ("All Files", "*.*")]
        )
        if not path:
            return

        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)

            # 데이터 구조를 기반으로 그리드와 파형을 재설정합니다.
            self._reconfigure_grid(data['config']['num_cycles'], data['config']['num_waves'])
            for i, sig_data in enumerate(data['signals']):
                self.model.signals[i].name.set(sig_data['name'])
                self.model.signals[i].mode.set(sig_data['mode'])
                self.model.signals[i].waveform = sig_data['waveform']
            self._redraw_all()
            self.status_var.set(f"Loaded waveform from {path}")
            messagebox.showinfo("Success", "Waveform loaded successfully!")
        except Exception as e:
            messagebox.showerror("Load Error", f"Failed to load or parse file:\n{e}")

    def _export_verilog_a(self):
        # 1. Parameter Input Dialog
        top = tk.Toplevel(self.master)
        top.title("Export Settings")
        top.geometry("350x250")
        top.transient(self.master)
        top.grab_set()
        
        var_tck = tk.StringVar(value="10n")
        var_tr = tk.StringVar(value="10p")
        var_tf = tk.StringVar(value="10p")
        var_vhigh = tk.StringVar(value="1.2")
        var_vlow = tk.StringVar(value="0.0")

        row = 0
        ttk.Label(top, text="[Time Parameters]").grid(row=row, column=0, sticky="w", padx=10, pady=(10,5))
        row += 1
        
        ttk.Label(top, text="Clock Period (tck):").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_tck, width=15).grid(row=row, column=1, padx=5, pady=2)
        ttk.Label(top, text="(GUI 2칸)").grid(row=row, column=2, sticky="w")
        row += 1
        
        ttk.Label(top, text="Rising Time (tr):").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_tr, width=15).grid(row=row, column=1, padx=5, pady=2)
        row += 1
        
        ttk.Label(top, text="Falling Time (tf):").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_tf, width=15).grid(row=row, column=1, padx=5, pady=2)
        row += 1
        
        ttk.Label(top, text="[Voltage Levels]").grid(row=row, column=0, sticky="w", padx=10, pady=(15,5))
        row += 1
        
        ttk.Label(top, text="V_High:").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_vhigh, width=15).grid(row=row, column=1, padx=5, pady=2)
        row += 1
        
        ttk.Label(top, text="V_Low:").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_vlow, width=15).grid(row=row, column=1, padx=5, pady=2)
        row += 1

        def on_export():
            if not all([var_tck.get(), var_tr.get(), var_tf.get(), var_vhigh.get()]):
                messagebox.showerror("Error", "All fields are required.")
                return
            
            try:
                vhigh = float(var_vhigh.get())
                vlow = float(var_vlow.get())
                params = {
                    'tck_str': var_tck.get(),
                    'tr_str': var_tr.get(),
                    'tf_str': var_tf.get(),
                    'vhigh': vhigh,
                    'vlow': vlow
                }
            except ValueError:
                messagebox.showerror("Error", "Voltage must be a number.")
                return

            # 모델에서 데이터 가져오기
            waveforms = [s.waveform for s in self.model.signals]
            names = [s.name.get() for s in self.model.signals]
            modes = [s.mode.get() for s in self.model.signals]
            
            try:
                # VerilogAGenerator는 순수 데이터 리스트를 받으므로 변경 없음
                code = VerilogAGenerator.generate(waveforms, names, modes, params)
            except Exception as e:
                messagebox.showerror("Generation Error", str(e))
                return
            
            top.destroy()
            path = filedialog.asksaveasfilename(defaultextension=".va", filetypes=[("Verilog-A", "*.va")])
            if path:
                with open(path, "w", encoding="utf-8") as f:
                    f.write(code)
                messagebox.showinfo("Success", f"Saved to {path}")

        btn_frame = ttk.Frame(top)
        btn_frame.grid(row=row+1, column=0, columnspan=3, pady=20)
        ttk.Button(btn_frame, text="Export", command=on_export).pack(side=tk.LEFT, padx=10)
        ttk.Button(btn_frame, text="Cancel", command=top.destroy).pack(side=tk.LEFT, padx=10)

if __name__ == "__main__":
    root = tk.Tk()
    try:
        from ctypes import windll
        windll.shcore.SetProcessDpiAwareness(1)
    except: pass
    app = WaveformEditor(root)
    root.mainloop()