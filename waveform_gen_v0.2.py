import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
from typing import List, Tuple, Dict
import re
import math

# ==========================================
# 1. Configuration Class (설정 관리)
# ==========================================
class WaveformConfig:
    """애플리케이션의 모든 상수와 설정을 관리하는 클래스"""
    def __init__(self):
        self.num_cycles = 64      # 기본 사이클 수
        self.num_waves = 4        # 기본 파형 개수
        self.cell_width = 20      # 한 클럭의 픽셀 너비
        self.row_height = 50      # 파형 한 줄의 높이
        
        # UI Colors & Layout
        self.high_y_offset = 10
        self.low_y_offset = 40
        self.grid_color = "#e0e0e0"
        self.wave_color = "#000000"
        self.sidebar_width = 340  # 컨트롤 패널 너비

    @property
    def total_width(self):
        return self.num_cycles * self.cell_width

    @property
    def total_height(self):
        return self.num_waves * self.row_height

# ==========================================
# 2. Logic Class: Verilog-A Generator
# ==========================================
class VerilogAGenerator:
    """
    GUI와 독립적으로 Verilog-A 코드를 생성하는 로직 클래스.
    ★ Drift 해결: $abstime 계산 방식을 버리고, @timer 이벤트 기반으로 값을 직접 할당.
    """
    
    @staticmethod
    def sanitize_name(name: str, default: str = "wave") -> str:
        s = name.strip()
        s = re.sub(r"[^A-Za-z0-9_]", "_", s)
        if not s: s = default
        if s[0].isdigit(): s = f"w_{s}"
        return s

    @staticmethod
    def generate(waveforms: List[List[int]], 
                 names: List[str], 
                 modes: List[str], 
                 params: Dict) -> str:
        
        tck_str = params.get('tck_str', '10n')
        tr_str = params.get('tr_str', '10p')
        tf_str = params.get('tf_str', '10p')
        vhigh = params['vhigh']
        vlow = params['vlow']
        
        sanitized_names = [VerilogAGenerator.sanitize_name(n, f"sig_{i}") for i, n in enumerate(names)]
        
        lines = [
            '// Auto-generated by Python Waveform Editor (Event-Driven Version)',
            '`include "discipline.h"',
            '`include "constants.h"',
            '',
            f'module pwl_waves({", ".join(sanitized_names)});',
            f'    output {", ".join(sanitized_names)};',
            f'    electrical {", ".join(sanitized_names)};',
            '',
            '    // User Parameters',
            f'    parameter real tck = {tck_str};  // Clock Period (1 Cycle)',
            f'    parameter real tr  = {tr_str};   // Rising Time',
            f'    parameter real tf  = {tf_str};   // Falling Time',
            f'    parameter real vlow = {vlow};',
            f'    parameter real vhigh = {vhigh};',
            ''
        ]

        real_vars = set()
        initial_block = []
        analog_body = []
        transitions = []

        for idx, wf in enumerate(waveforms):
            name = sanitized_names[idx]
            mode = modes[idx]
            vsel = f"vsel_{idx}"
            real_vars.add(vsel)
            
            # 1. 초기 상태 설정 (@initial_step)
            # 파형의 0번째 값을 초기값으로 설정
            init_val = vhigh if wf and wf[0] else vlow
            initial_block.append(f"        {vsel} = {init_val:.12g};")

            analog_body.append(f"    // Logic for {name} ({mode}) - Event Driven")
            
            gui_len = len(wf)
            is_periodic = (mode == "반복")
            
            # 2. 변경 포인트 감지 및 @timer 코드 생성
            # 계산 로직(if-else)을 쓰지 않고, 타이머 이벤트 안에서 직접 값을 대입함
            
            if is_periodic:
                # 주기 계산 (GUI 전체 길이)
                period_expr = f"({gui_len * 0.5:.12g} * tck)"
                
                # (1) Wrap-around 처리 (마지막 값 -> 첫 값 변경 시 0초에 이벤트 필요)
                # 주기적 신호는 wf[-1]에서 wf[0]으로 넘어갈 때 값이 다르면 0초 타이머가 필요함
                prev_val = wf[-1] 
                
                # 0부터 끝까지 순회
                for i in range(len(wf)):
                    curr_val = wf[i]
                    if curr_val != prev_val:
                        # 값이 변하는 순간!
                        time_offset = i * 0.5
                        target_volt = vhigh if curr_val else vlow
                        
                        # @timer(시작시간, 주기)
                        if time_offset == 0:
                            # 0초(주기 시작점) 타이머
                            analog_body.append(f"    @(timer(0, {period_expr})) {vsel} = {target_volt:.12g};")
                        else:
                            # 중간 타이머
                            analog_body.append(f"    @(timer({time_offset:.12g} * tck, {period_expr})) {vsel} = {target_volt:.12g};")
                    
                    prev_val = curr_val
                    
            else:
                # One-shot 모드
                prev_val = wf[0]
                # 0번째 인덱스는 초기값으로 설정되므로, 1번째부터 변화 감지
                for i in range(1, len(wf)):
                    curr_val = wf[i]
                    if curr_val != prev_val:
                        time_offset = i * 0.5
                        target_volt = vhigh if curr_val else vlow
                        # 반복 없는 단발성 타이머
                        analog_body.append(f"    @(timer({time_offset:.12g} * tck)) {vsel} = {target_volt:.12g};")
                        prev_val = curr_val
                
                # GUI 윈도우가 끝난 후 0(Low)으로 떨어지도록 설정 (옵션)
                end_time_expr = f"({gui_len * 0.5:.12g} * tck)"
                if prev_val != 0: # 마지막이 High 상태로 끝났다면
                     analog_body.append(f"    @(timer({end_time_expr})) {vsel} = {vlow:.12g};")

            analog_body.append("")
            transitions.append(f"    V({name}) <+ transition({vsel}, 0, tr, tf);")

        if real_vars: lines.append(f"    real {', '.join(sorted(list(real_vars)))};")
        
        # 정수는 더 이상 필요 없음 (n_0, n_1 등 삭제)
            
        lines.append("\n    analog begin")
        
        # 초기화 블록
        if initial_block:
            lines.append("        @(initial_step) begin")
            lines.extend(initial_block)
            lines.append("        end\n")
            
        lines.extend(analog_body)
        lines.extend(transitions)
        lines.append("    end")
        lines.append("endmodule")
        return "\n".join(lines)


# ==========================================
# 3. Main GUI Class
# ==========================================
class WaveformEditor:
    def __init__(self, master: tk.Tk):
        self.master = master
        self.cfg = WaveformConfig()
        self.master.title(f"Waveform Editor - {self.cfg.num_cycles} Cycles")
        
        # Data Model
        self.waveforms = [[0] * self.cfg.num_cycles for _ in range(self.cfg.num_waves)]
        self.active_wave_idx = 0
        self.cursor_index = 0
        self.pulse_len_buf = ""
        
        # Variables List
        self.signal_vars: List[tk.StringVar] = []
        self.mode_vars: List[tk.StringVar] = []
        
        # UI Setup
        self._setup_menu()
        self._setup_layout()
        
        # 초기 파형 변수 생성
        for i in range(self.cfg.num_waves):
            self._add_wave_vars(i)
            
        self._rebuild_control_panel()
        self._bind_events()
        self._redraw_all()
        
        self.status_var.set("Ready. 'CLK'를 이름에 입력하면 자동 클럭이 생성됩니다.")

    def _add_wave_vars(self, idx):
        """파형별 이름/모드 변수 생성 및 이벤트 연결"""
        sv = tk.StringVar(value=f"Signal_{idx+1}")
        mv = tk.StringVar(value="one-shot")
        
        # CLK 입력 감지
        sv.trace_add("write", lambda *_, i=idx: self._check_clk_name(i))
        
        self.signal_vars.append(sv)
        self.mode_vars.append(mv)

    def _setup_menu(self):
        menubar = tk.Menu(self.master)
        self.master.config(menu=menubar)
        settings_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="설정 (Settings)", menu=settings_menu)
        settings_menu.add_command(label="그리드 크기 변경 (Grid Size)...", command=self._open_grid_settings)

    def _setup_layout(self):
        self.main_pane = ttk.PanedWindow(self.master, orient=tk.HORIZONTAL)
        self.main_pane.pack(fill=tk.BOTH, expand=True)
        
        # Left Sidebar
        self.sidebar = ttk.Frame(self.main_pane, width=200)
        self.main_pane.add(self.sidebar, weight=0)
        
        info_frame = ttk.LabelFrame(self.sidebar, text="Info", padding=5)
        info_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.text_info = tk.Text(info_frame, width=25, height=10, state="disabled", font=("Consolas", 9))
        self.text_info.pack(fill=tk.BOTH, expand=True)
        
        btn_frame = ttk.Frame(self.sidebar, padding=5)
        btn_frame.pack(fill=tk.X, side=tk.BOTTOM)
        ttk.Button(btn_frame, text="Clear Wave", command=self._clear_current_wave).pack(fill=tk.X, pady=2)
        ttk.Button(btn_frame, text="Export Verilog-A", command=self._export_verilog_a).pack(fill=tk.X, pady=2)

        # Work Area
        self.work_area = ttk.Frame(self.main_pane)
        self.main_pane.add(self.work_area, weight=1)
        
        self.h_scroll = ttk.Scrollbar(self.work_area, orient="horizontal")
        self.h_scroll.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.wave_container = ttk.Frame(self.work_area)
        self.wave_container.pack(fill=tk.BOTH, expand=True)
        
        self.controls_frame = ttk.Frame(self.wave_container, width=self.cfg.sidebar_width)
        self.controls_frame.pack(side=tk.LEFT, fill=tk.Y)
        self.controls_frame.pack_propagate(False)
        
        self.canvas = tk.Canvas(self.wave_container, bg="white", highlightthickness=0)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.canvas.configure(xscrollcommand=self.h_scroll.set)
        self.h_scroll.configure(command=self.canvas.xview)
        
        self.status_var = tk.StringVar()
        self.statusbar = ttk.Label(self.master, textvariable=self.status_var, relief=tk.SUNKEN, anchor="w")
        self.statusbar.pack(side=tk.BOTTOM, fill=tk.X)

    def _rebuild_control_panel(self):
        for widget in self.controls_frame.winfo_children():
            widget.destroy()
            
        for i in range(len(self.signal_vars)):
            row_f = ttk.Frame(self.controls_frame, height=self.cfg.row_height)
            row_f.pack(fill=tk.X, pady=0)
            row_f.pack_propagate(False)
            
            ttk.Label(row_f, text=f"W{i+1}", width=3, anchor="center").pack(side=tk.LEFT, padx=2, pady=10)
            
            entry = ttk.Entry(row_f, textvariable=self.signal_vars[i], width=10, justify="center")
            entry.pack(side=tk.LEFT, padx=2, pady=10, fill=tk.Y)
            
            combo = ttk.Combobox(row_f, textvariable=self.mode_vars[i], values=["one-shot", "반복"], width=8, state="readonly")
            combo.pack(side=tk.LEFT, padx=2, pady=10, fill=tk.Y)

    def _check_clk_name(self, idx):
        if idx >= len(self.signal_vars): return
        name = self.signal_vars[idx].get().lower().strip()
        if name == "clk":
            self.waveforms[idx] = [i % 2 for i in range(self.cfg.num_cycles)]
            self.mode_vars[idx].set("반복")
            self._redraw_all()
            self.status_var.set(f"Wave {idx+1}: Auto-generated CLK pattern.")

    def _open_grid_settings(self):
        top = tk.Toplevel(self.master)
        top.title("Grid Settings")
        top.geometry("300x160")
        top.transient(self.master)
        top.grab_set()

        ttk.Label(top, text="Cycles (Length):").place(x=30, y=30)
        entry_cycles = ttk.Entry(top, width=10)
        entry_cycles.place(x=150, y=30)
        entry_cycles.insert(0, str(self.cfg.num_cycles))

        ttk.Label(top, text="Waves (Count):").place(x=30, y=70)
        entry_waves = ttk.Entry(top, width=10)
        entry_waves.place(x=150, y=70)
        entry_waves.insert(0, str(self.cfg.num_waves))

        def on_confirm():
            try:
                nc = int(entry_cycles.get())
                nw = int(entry_waves.get())
                if nc < 1 or nw < 1: raise ValueError
                self._reconfigure_grid(nc, nw)
                top.destroy()
            except ValueError:
                messagebox.showerror("Error", "Please enter positive integers.")

        ttk.Button(top, text="Apply", command=on_confirm).place(x=100, y=110)
        top.bind("<Return>", lambda e: on_confirm())

    def _reconfigure_grid(self, new_cycles: int, new_waves: int):
        old_cycles = self.cfg.num_cycles
        old_waves = self.cfg.num_waves

        self.cfg.num_cycles = new_cycles
        self.cfg.num_waves = new_waves

        if new_waves > old_waves:
            for i in range(old_waves, new_waves):
                self.waveforms.append([0] * old_cycles)
                self._add_wave_vars(i)
        elif new_waves < old_waves:
            self.waveforms = self.waveforms[:new_waves]
            self.signal_vars = self.signal_vars[:new_waves]
            self.mode_vars = self.mode_vars[:new_waves]

        for i in range(new_waves):
            curr = len(self.waveforms[i])
            if new_cycles > curr:
                self.waveforms[i].extend([0] * (new_cycles - curr))
            elif new_cycles < curr:
                self.waveforms[i] = self.waveforms[i][:new_cycles]

        self._rebuild_control_panel()
        self.master.title(f"Waveform Editor - {self.cfg.num_cycles} Cycles")
        self.active_wave_idx = 0
        self.cursor_index = 0
        self._redraw_all()
        self.status_var.set(f"Resized: {new_waves} Waves x {new_cycles} Cycles")

    def _bind_events(self):
        self.canvas.bind("<Button-1>", lambda e: self._handle_click(e, 1)) 
        self.canvas.bind("<B1-Motion>", lambda e: self._handle_drag(e, 1))
        self.canvas.bind("<Button-3>", lambda e: self._handle_click(e, 0))
        self.canvas.bind("<B3-Motion>", lambda e: self._handle_drag(e, 0))
        
        self.master.bind("<Key>", self._on_key_press)
        self.master.bind("<Return>", lambda e: self._apply_buffered_length(1))
        self.master.bind("<Shift-Return>", lambda e: self._apply_buffered_length(0))

    def _redraw_all(self):
        self.canvas.delete("all")
        total_w = self.cfg.total_width
        total_h = self.cfg.total_height
        
        self.canvas.configure(scrollregion=(0, 0, total_w + 50, total_h))
        
        for i in range(self.cfg.num_waves):
            y_base = i * self.cfg.row_height
            self.canvas.create_line(0, y_base, total_w, y_base, fill=self.cfg.grid_color)
            if i == self.active_wave_idx:
                self.canvas.create_rectangle(0, y_base, total_w, y_base + self.cfg.row_height, 
                                             fill="#f0f8ff", outline="", tags="bg")

        for c in range(self.cfg.num_cycles + 1):
            x = c * self.cfg.cell_width
            self.canvas.create_line(x, 0, x, total_h, fill=self.cfg.grid_color, dash=(2, 4))
            if c % 4 == 0:
                self.canvas.create_text(x + 2, total_h - 10, text=str(c), anchor="sw", fill="gray", font=("", 8))

        for i in range(self.cfg.num_waves):
            self._draw_single_wave(i)

    def _draw_single_wave(self, idx):
        wf = self.waveforms[idx]
        y_base = idx * self.cfg.row_height
        high_y = y_base + self.cfg.high_y_offset
        low_y = y_base + self.cfg.low_y_offset
        
        points = []
        cur_x = 0
        cur_y = high_y if wf[0] else low_y
        points.append(cur_x); points.append(cur_y)
        
        for c in range(1, len(wf)):
            x = c * self.cfg.cell_width
            prev = wf[c-1]
            curr = wf[c]
            target_y = high_y if curr else low_y
            if prev != curr:
                points.append(x); points.append(cur_y)
                points.append(x); points.append(target_y)
                cur_y = target_y
        points.append(len(wf) * self.cfg.cell_width)
        points.append(cur_y)
        
        color = "blue" if idx == self.active_wave_idx else self.cfg.wave_color
        width = 3 if idx == self.active_wave_idx else 2
        self.canvas.create_line(points, fill=color, width=width, tags=f"wave_{idx}")

    def _get_target_from_event(self, event) -> Tuple[int, int]:
        cx = self.canvas.canvasx(event.x)
        cy = self.canvas.canvasy(event.y)
        w_idx = int(cy // self.cfg.row_height)
        c_idx = int(cx // self.cfg.cell_width)
        w_idx = max(0, min(w_idx, self.cfg.num_waves - 1))
        c_idx = max(0, min(c_idx, self.cfg.num_cycles - 1))
        return w_idx, c_idx

    def _handle_click(self, event, val):
        self.master.focus_set()
        w_idx, c_idx = self._get_target_from_event(event)
        self.active_wave_idx = w_idx
        self.cursor_index = c_idx
        self.pulse_len_buf = ""
        self.waveforms[w_idx][c_idx] = val
        self._update_ui_after_change()

    def _handle_drag(self, event, val):
        w_idx, c_idx = self._get_target_from_event(event)
        if w_idx != self.active_wave_idx:
            self.active_wave_idx = w_idx
        self.waveforms[w_idx][c_idx] = val
        self.cursor_index = c_idx
        self._update_ui_after_change()

    def _update_ui_after_change(self):
        self._redraw_all()
        self._update_info_panel()
        val_str = "HIGH" if self.waveforms[self.active_wave_idx][self.cursor_index] else "LOW"
        self.status_var.set(f"Wave {self.active_wave_idx+1} @ {self.cursor_index}: Set {val_str}")

    def _on_key_press(self, event):
        if isinstance(self.master.focus_get(), ttk.Entry): return
        if event.char.isdigit():
            self.pulse_len_buf += event.char
            self.status_var.set(f"Input Length: {self.pulse_len_buf} (Press Enter to Apply High)")

    def _apply_buffered_length(self, val):
        if not self.pulse_len_buf: return
        try:
            length = int(self.pulse_len_buf)
            start = self.cursor_index
            end = min(self.cfg.num_cycles, start + length)
            for i in range(start, end):
                self.waveforms[self.active_wave_idx][i] = val
            self._update_ui_after_change()
            self.pulse_len_buf = ""
        except ValueError: pass

    def _update_info_panel(self):
        self.text_info.configure(state="normal")
        self.text_info.delete("1.0", tk.END)
        wf = self.waveforms[self.active_wave_idx]
        pulses = []
        in_pulse = False
        start = 0
        for i, v in enumerate(wf):
            if v == 1 and not in_pulse:
                in_pulse = True; start = i
            elif v == 0 and in_pulse:
                in_pulse = False; pulses.append((start, i - start))
        if in_pulse: pulses.append((start, len(wf) - start))
        
        self.text_info.insert(tk.END, f"[Signal {self.active_wave_idx+1}]\nTotal: {len(wf)}\nPulses: {len(pulses)}\n\n")
        for i, (s, w) in enumerate(pulses):
            self.text_info.insert(tk.END, f"#{i+1}: Start={s}, W={w}\n")
        self.text_info.configure(state="disabled")

    def _clear_current_wave(self):
        self.waveforms[self.active_wave_idx] = [0] * self.cfg.num_cycles
        self._update_ui_after_change()

    def _export_verilog_a(self):
        # 1. Parameter Input Dialog
        top = tk.Toplevel(self.master)
        top.title("Export Settings")
        top.geometry("350x250")
        top.transient(self.master)
        top.grab_set()
        
        var_tck = tk.StringVar(value="10n")
        var_tr = tk.StringVar(value="10p")
        var_tf = tk.StringVar(value="10p")
        var_vhigh = tk.StringVar(value="1.2")
        var_vlow = tk.StringVar(value="0.0")

        row = 0
        ttk.Label(top, text="[Time Parameters]").grid(row=row, column=0, sticky="w", padx=10, pady=(10,5))
        row += 1
        
        ttk.Label(top, text="Clock Period (tck):").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_tck, width=15).grid(row=row, column=1, padx=5, pady=2)
        ttk.Label(top, text="(GUI 2칸)").grid(row=row, column=2, sticky="w")
        row += 1
        
        ttk.Label(top, text="Rising Time (tr):").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_tr, width=15).grid(row=row, column=1, padx=5, pady=2)
        row += 1
        
        ttk.Label(top, text="Falling Time (tf):").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_tf, width=15).grid(row=row, column=1, padx=5, pady=2)
        row += 1
        
        ttk.Label(top, text="[Voltage Levels]").grid(row=row, column=0, sticky="w", padx=10, pady=(15,5))
        row += 1
        
        ttk.Label(top, text="V_High:").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_vhigh, width=15).grid(row=row, column=1, padx=5, pady=2)
        row += 1
        
        ttk.Label(top, text="V_Low:").grid(row=row, column=0, sticky="e", padx=5)
        ttk.Entry(top, textvariable=var_vlow, width=15).grid(row=row, column=1, padx=5, pady=2)
        row += 1

        def on_export():
            if not all([var_tck.get(), var_tr.get(), var_tf.get(), var_vhigh.get()]):
                messagebox.showerror("Error", "All fields are required.")
                return
            
            try:
                vhigh = float(var_vhigh.get())
                vlow = float(var_vlow.get())
                params = {
                    'tck_str': var_tck.get(),
                    'tr_str': var_tr.get(),
                    'tf_str': var_tf.get(),
                    'vhigh': vhigh,
                    'vlow': vlow
                }
            except ValueError:
                messagebox.showerror("Error", "Voltage must be a number.")
                return

            names = [v.get() for v in self.signal_vars]
            modes = [v.get() for v in self.mode_vars]
            
            try:
                code = VerilogAGenerator.generate(self.waveforms, names, modes, params)
            except Exception as e:
                messagebox.showerror("Generation Error", str(e))
                return
            
            top.destroy()
            path = filedialog.asksaveasfilename(defaultextension=".va", filetypes=[("Verilog-A", "*.va")])
            if path:
                with open(path, "w", encoding="utf-8") as f:
                    f.write(code)
                messagebox.showinfo("Success", f"Saved to {path}")

        btn_frame = ttk.Frame(top)
        btn_frame.grid(row=row+1, column=0, columnspan=3, pady=20)
        ttk.Button(btn_frame, text="Export", command=on_export).pack(side=tk.LEFT, padx=10)
        ttk.Button(btn_frame, text="Cancel", command=top.destroy).pack(side=tk.LEFT, padx=10)

if __name__ == "__main__":
    root = tk.Tk()
    try:
        from ctypes import windll
        windll.shcore.SetProcessDpiAwareness(1)
    except: pass
    app = WaveformEditor(root)
    root.mainloop()